<!DOCTYPE html>
<html>
<head>
	<title>WebGL Playground</title>
	<link rel="stylesheet" type="text/css" href="style.css">
	<script src="gl.js"></script>
	<script src="Shaders.js"></script>
	<script src="RenderLoop.js"></script>
	<script src="Modal.js"></script>
	<script>
		//Global variables init
		var gl,
			gVertCount = 0,
			uPointSizeLoc = -1,
			uAngle = 0,
			uRadius = 0,
			gRLoop,
			gShader = null,
			gModal = null;


		window.addEventListener("load", function(){
			gl= GLInstance("glcanvas"); // Init context
			gl.fSetSize(500,500); //Setting size
			gl.fClear(); //Reseting context

			gShader = new TestShader(gl);

			var mesh = gl.fCreateMeshVAO("dots", null, [0,0,0, 0.1,0.1,0, 0.1,-0.1,0, -0.1,-0.1,0, -0.1,0.1,0]);
			mesh.drawMode = gl.POINTS;

			gModal = new Modal(mesh);
				
			RLoop = new RenderLoop(onRender).start();
		});

		var gPointSize = 0;
			gPSizeStep = 3,
			gAngle = 0,
			gAngleStep = (Math.PI / 180.0) * 90,
			gRadius = 0,
			gRadiusStep = 0.1;

		var growing = true;


		function onRender(dt){
/*			gPointSize += gPSizeStep * dt;
			var size = (Math.sin(gPointSize)*10.0)+20;
			gl.uniform1f(uPointSizeLoc,size);

			gAngle += gAngleStep *dt;
			gl.uniform1f(uAngle,gAngle);

			gRadius += gRadiusStep * dt;
			gl.uniform1f(uRadius,Math.sin(gRadius));

			gl.fClear();
			gl.drawArrays(gl.POINTS, 0, gVertCount);*/

			gl.fClear();

			gShader.activate();
			gShader.set(
				(Math.sin((gPointSize += gPSizeStep * dt))*10.0)+30.0,
				(gAngle += gAngleStep *dt));
			gShader.renderModal(gModal);
		}

		class TestShader extends Shader{
			constructor(gl){
				var vertSrc = ShaderUtil.domShaderSrc("vertex_shader"),
					fragSrc = ShaderUtil.domShaderSrc("fragment_shader");
				super(gl,vertSrc,fragSrc);	//Call the base class constructor which will setup most of what we need

				//Our shader uses custom uniforms, this is the time to get its location for future use.
				this.uniformLoc.uPointSize	= gl.getUniformLocation(this.program,"uPointSize");
				this.uniformLoc.uAngle		= gl.getUniformLocation(this.program,"uAngle");

				gl.useProgram(null); //Done setting up shader
			}

				//Simple function that passes in Angle and Pointsize uniform data to the shader program.
			set(size,angle){
				this.gl.uniform1f(this.uniformLoc.uPointSize,size);
				this.gl.uniform1f(this.uniformLoc.uAngle,angle);
				return this;
			}
		}
	</script>
</head>
<body>
	<div>
		<canvas id="glcanvas"></canvas>
	</div>
	<script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
		in vec3 a_position;
		
		uniform mediump float uPointSize;
		uniform float uAngle;
		uniform float uRadius;

		void main(void){
			gl_PointSize = uPointSize;
			gl_Position = vec4(cos(uAngle) *0.8 + a_position.x,
			sin(uAngle) * 0.8 + a_position.y,
			a_position.z,
			1.0);
		}
	</script>
	<script id="fragment_shader" type="x-shader/x-fragment">#version 300 es
		precision mediump float;

		uniform float uPointSize;
		out vec4 finalColor;
		
		void main(void) {
			float c = (40.0 - uPointSize) / 20.0;
			finalColor = vec4(c, c, c, 1.0);
		}
	</script>
</body>
</html>